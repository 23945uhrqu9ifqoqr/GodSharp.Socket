using GodSharp.Protocol;
using System;
using System.Diagnostics.CodeAnalysis;
using System.Net;
using System.Net.Sockets;
using System.Threading;
// ReSharper disable ArrangeThisQualifier

namespace GodSharp
{
    public class SocketClient : SocketBase, IDisposable
    {
        /// <summary>Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="M:System.Net.Sockets.Socket.Send" /> or <see cref="M:System.Net.Sockets.Socket.Receive" /> operation.</summary>
        /// <returns>true if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, false.</returns>
        public bool Connected => socket != null && socket.Connected;

        /// <summary>Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        /// <returns>An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer. The default is 8192.</returns>
        public int ReceiveBufferSize
        {
            get { return socket?.ReceiveBufferSize ?? 8192; }
            set { if (socket != null) socket.ReceiveBufferSize = value; }
        }

        /// <summary>Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        /// <returns>An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer. The default is 8192.</returns>
        public int SendBufferSize
        {
            get { return socket?.SendBufferSize ?? 8192; }
            set { if (socket != null) socket.SendBufferSize = value; }
        }

        /// <summary>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="M:System.Net.Sockets.Socket.Receive" /> call will time out.</summary>
        /// <returns>The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</returns>
        public int ReceiveTimeout
        {
            get { return socket?.ReceiveTimeout ?? 0; }
            set { if (socket != null) socket.ReceiveTimeout = value; }
        }

        /// <summary>Gets or sets a value that specifies the amount of time after which a synchronous <see cref="M:System.Net.Sockets.Socket.Send" /> call will time out.</summary>
        /// <returns>The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.</returns>
        public int SendTimeout
        {
            get { return socket?.SendTimeout ?? 0; }
            set { if (socket != null) socket.SendTimeout = value; }
        }

        /// <summary>
        /// The execute method when received data.
        /// </summary>
        public Action<SocketClient, byte[]> OnData { get; set; }

        /// <summary>
        /// Gets the remote endpoint.
        /// </summary>
        public new EndPoint RemoteEndPoint => socket.RemoteEndPoint;

        // This is generated by the compiler and can be safely removed
        /// <summary>
        /// Initializes a new instance of the <see cref="SocketClient" /> class.
        /// </summary>
        private SocketClient()
        {
            host = "127.0.0.1";
            OnData = null;
        }

        /// <summary>
        ///Initializes a new instance of the <see cref="SocketClient" /> class using specified port.
        /// </summary>
        /// <param name="host">The remote host.</param>
        /// <param name="port">The int number of server port.</param>
        public SocketClient(string host = "127.0.0.1", int port = 7788) : this()
        {
            if (!string.IsNullOrEmpty(host))
            {
                bool flag = IPAddress.TryParse(host, out IPAddress _);

                if (!flag)
                {
                    throw new InvalidCastException("host must be a ip address string.");
                }
            }
            else
            {
                host = null;
            }

            base.host = host ?? base.host;
            base.port = port;

            socket = new Socket(addressFamily, socketType, protocolType);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SocketClient" /> class.
        /// </summary>
        /// <param name="host">The remote host.</param>
        /// <param name="port">The int number of server port.</param>
        /// <param name="addressFamily">The address family of the <see cref="T:Socket" />.</param>
        /// <param name="socketType">The type of the <see cref="T:Socket" />.</param>
        /// <param name="protocolType">The protocol type of the <see cref="T:Socket" />.</param>
        public SocketClient(string host = "127.0.0.1", int port = 7788, AddressFamily addressFamily = AddressFamily.InterNetwork, SocketType socketType = SocketType.Stream, ProtocolType protocolType = ProtocolType.Tcp) : this()
        {

            if (!string.IsNullOrEmpty(host))
            {
                bool flag = IPAddress.TryParse(host, out IPAddress _);

                if (!flag)
                {
                    throw new InvalidCastException("host must be a ip address string.");
                }
            }
            else
            {
                host = null;
            }

            base.host = host ?? base.host;
            base.port = port;
            base.addressFamily = addressFamily;
            base.socketType = socketType;
            base.protocolType = protocolType;

            socket = new Socket(base.addressFamily, base.socketType, base.protocolType);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SocketClient" /> class.
        /// </summary>
        /// <param name="port">The int number of server port.</param>
        /// <param name="addressFamily">The address family of the <see cref="T:Socket" />.</param>
        /// <param name="socketType">The type of the <see cref="T:Socket" />.</param>
        /// <param name="protocolType">The protocol type of the <see cref="T:Socket" />.</param>
        public SocketClient(int port = 7788, AddressFamily addressFamily = AddressFamily.InterNetwork, SocketType socketType = SocketType.Stream, ProtocolType protocolType = ProtocolType.Tcp) : this()
        {
            base.port = port;
            base.addressFamily = addressFamily;
            base.socketType = socketType;
            base.protocolType = protocolType;

            socket = new Socket(base.addressFamily, base.socketType, base.protocolType);
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="SocketClient" /> class.
        /// </summary>
        /// <param name="addressFamily">The address family of the <see cref="T:Socket" />.</param>
        /// <param name="socketType">The type of the <see cref="T:Socket" />.</param>
        /// <param name="protocolType">The protocol type of the <see cref="T:Socket" />.</param>
        public SocketClient(AddressFamily addressFamily = AddressFamily.InterNetwork, SocketType socketType = SocketType.Stream, ProtocolType protocolType = ProtocolType.Tcp)
        {
            base.addressFamily = addressFamily;
            base.socketType = socketType;
            base.protocolType = protocolType;
            socket = new Socket(base.addressFamily, base.socketType, base.protocolType);
        }

        ~SocketClient()
        {
            Dispose(false);
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        protected void Dispose(bool disposing)
        {
            if (disposing)
            {
            }
        }


        /// <summary>Begins an asynchronous request for a remote host connection.</summary>
        /// <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        /// <param name="remoteEp">An <see cref="T:System.Net.EndPoint" /> that represents the remote host. </param>
        /// <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate. </param>
        /// <param name="state">An object that contains state information for this request. </param>
        public IAsyncResult BeginConnect(EndPoint remoteEp, AsyncCallback callback, object state)
        {
            return socket.BeginConnect(remoteEp, callback, state);
        }

        /// <summary>Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.</summary>
        /// <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        /// <param name="host">The name of the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        /// <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete. </param>
        /// <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        public IAsyncResult BeginConnect(string host, int port, AsyncCallback requestCallback, object state)
        {
            return socket.BeginConnect(host, port, requestCallback, state);
        }

        /// <summary>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</summary>
        /// <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</returns>
        /// <param name="address">The <see cref="T:System.Net.IPAddress" /> of the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        /// <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete. </param>
        /// <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        public IAsyncResult BeginConnect(IPAddress address, int port, AsyncCallback requestCallback, object state)
        {
            return socket.BeginConnect(address, port, requestCallback, state);
        }

        /// <summary>Begins an asynchronous request for a remote host connection. The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</summary>
        /// <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</returns>
        /// <param name="addresses">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        /// <param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete. </param>
        /// <param name="state">A user-defined object that contains information about the connect operation. This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</param>
        public IAsyncResult BeginConnect(IPAddress[] addresses, int port, AsyncCallback requestCallback, object state)
        {
            return socket.BeginConnect(addresses, port, requestCallback, state);
        }

        /// <summary>Begins an asynchronous request to disconnect from a remote endpoint.</summary>
        /// <returns>An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</returns>
        /// <param name="reuseSocket">true if this socket can be reused after the connection is closed; otherwise, false. </param>
        /// <param name="callback">The <see cref="T:System.AsyncCallback" /> delegate. </param>
        /// <param name="state">An object that contains state information for this request. </param>
        public IAsyncResult BeginDisconnect(bool reuseSocket, AsyncCallback callback, object state)
        {
            return socket.BeginDisconnect(reuseSocket, callback, state);
        }

        /// <summary>Establishes a connection to a remote host.</summary>
        /// <param name="remoteEp">An <see cref="T:System.Net.EndPoint" /> that represents the remote device. </param>
        public void Connect(EndPoint remoteEp)
        {
            socket.Connect(remoteEp);
        }

        /// <summary>Establishes a connection to a remote host. The host is specified by an IP address and a port number.</summary>
        /// <param name="address">The IP address of the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        public void Connect(IPAddress address, int port)
        {
            socket.Connect(address, port);
        }

        /// <summary>Establishes a connection to a remote host. The host is specified by a host name and a port number.</summary>
        /// <param name="host">The name of the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        public void Connect(string host, int port)
        {
            socket.Connect(host, port);
        }

        /// <summary>Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.</summary>
        /// <param name="addresses">The IP addresses of the remote host.</param>
        /// <param name="port">The port number of the remote host.</param>
        public void Connect(IPAddress[] addresses, int port)
        {
            socket.Connect(addresses, port);
        }

        /// <summary>Begins an asynchronous request for a remote host connection.</summary>
        /// <returns>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation. </returns>
        /// <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        public bool ConnectAsync(SocketAsyncEventArgs e)
        {
            return socket.ConnectAsync(e);
        }

        /// <summary>Closes the socket connection and allows reuse of the socket.</summary>
        /// <param name="reuseSocket">true if this socket can be reused after the current connection is closed; otherwise, false. </param>
        public void Disconnect(bool reuseSocket)
        {
            socket.Disconnect(reuseSocket);
        }

        /// <summary>Begins an asynchronous request to disconnect from a remote endpoint.</summary>
        /// <returns>Returns true if the I/O operation is pending. The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation. Returns false if the I/O operation completed synchronously. In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</returns>
        /// <param name="e">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</param>
        public bool DisconnectAsync(SocketAsyncEventArgs e)
        {
            return socket.DisconnectAsync(e);
        }

        /// <summary>Ends a pending asynchronous connection request.</summary>
        /// <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation. </param>
        public void EndConnect(IAsyncResult asyncResult)
        {
            socket.EndConnect(asyncResult);
        }

        /// <summary>Ends a pending asynchronous disconnect request.</summary>
        /// <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation. </param>
        public void EndDisconnect(IAsyncResult asyncResult)
        {
            socket.EndDisconnect(asyncResult);
        }

        /// <summary>Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</summary>
        /// <returns>The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.Mode Return Value <see cref="F:System.Net.Sockets.SelectMode.SelectRead" />true if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending; -or- true if data is available for reading; -or- true if the connection has been closed, reset, or terminated; otherwise, returns false. <see cref="F:System.Net.Sockets.SelectMode.SelectWrite" />true, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded; -or- true if data can be sent; otherwise, returns false. <see cref="F:System.Net.Sockets.SelectMode.SelectError" />true if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed; -or- true if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available; otherwise, returns false. </returns>
        /// <param name="microSeconds">The time to wait for a response, in microseconds. </param>
        /// <param name="mode">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values. </param>
        /// <exception cref="T:System.NotSupportedException">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values. </exception>
        public bool Poll(int microSeconds, SelectMode mode)
        {
            return socket.Poll(microSeconds, mode);
        }

        ///------------------------------------------

        /// <summary>
        /// Connect to server.
        /// </summary>
        public void Connect()
        {
            try
            {
                IPAddress ip = string.IsNullOrEmpty(host) ? IPAddress.Any : IPAddress.Parse(host);

                socket.Connect(new IPEndPoint(ip, port));
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
        }

        /// <summary>
        /// Start Socket client.
        /// </summary>
        public void Start()
        {
            try
            {
                if (!socket.Connected)
                {
                    Console.WriteLine("Socket server not connected.");
                    return;
                }

                if (threadHandle != null)
                {
                    return;
                }

                threadHandle = new Thread(Loop)
                {
                    IsBackground = true
                };
                threadHandle.Start();
                Console.WriteLine($"Socket client {socket.LocalEndPoint} started");
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
                throw new Exception(ex.Message,ex);
            }
        }

        /// <summary>
        /// Polling method.
        /// </summary>
        [SuppressMessage("ReSharper", "RedundantAssignment")]
        internal void Loop()
        {
            try
            {
                // ReSharper disable once TooWideLocalVariableScope
                byte[] data;
                // ReSharper disable once TooWideLocalVariableScope
                SocketResult<SocketClient> result;
                // ReSharper disable once TooWideLocalVariableScope
                int length;
                while (loopFlag)
                {
                    try
                    {
                        data = new byte[1024];
                        length = -1;
                        length = socket.Receive(data);

                        if (length < 1)
                        {
                            continue;
                        }

                        byte[] tmp = new byte[length];
                        Buffer.BlockCopy(data, 0, tmp, 0, length);

                        result = null;
                        //this.RemoteEndPoint = socket.RemoteEndPoint;
                        result = new SocketResult<SocketClient>() {Socket = this, Bytes = tmp, OnData = OnData};

                        Thread processThread = new Thread(ProcessData<SocketClient>)
                        {
                            IsBackground = true
                        };
                        processThread.Start(result);
                    }
                    catch (SocketException ex)
                    {
                        Console.WriteLine(ex.Message);
                        if (ex.SocketErrorCode == SocketError.ConnectionReset || ex.SocketErrorCode == SocketError.ConnectionAborted)
                        {
                            //Console.WriteLine($"Server {socket.RemoteEndPoint} offline.");
                            socket.Shutdown(SocketShutdown.Both);
                            socket.Close();
                            break;
                        }
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex.Message);
                        continue;
                    }

                    Thread.Sleep(10);
                }
            }
            catch (Exception e)
            {
                Console.WriteLine(e);
            }
            this.status = SocketStatus.Stop;
        }
    }
}